/**************************************************************************************************
**
**
** TODO: License
**
** Author: Ondrej Ille
**************************************************************************************************/

#ifndef SPECT_LIB_CPU_SIMULATOR_H_
#define SPECT_LIB_CPU_SIMULATOR_H_

#include <vector>
#include <iostream>

#include "Instruction.h"

#include "cli.h"
#include "clilocalsession.h"
#include "loopscheduler.h"

class spect::CpuSimulator
{
    public:

        ///////////////////////////////////////////////////////////////////////////////////////////
        /// @brief New CPU simulator constructor
        /// @returns New model object
        ///////////////////////////////////////////////////////////////////////////////////////////
        CpuSimulator();

        ///////////////////////////////////////////////////////////////////////////////////////////
        /// @brief CPU Simulator destructor
        ///////////////////////////////////////////////////////////////////////////////////////////
        ~CpuSimulator();

        ///////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Add breakpoint
        /// @param address Address in program where to add breakpoint
        /// @returns True - Breakpoint added, False if breakpoint already exists
        ///////////////////////////////////////////////////////////////////////////////////////////
        bool AddBreakpoint(uint16_t address);

        ///////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Add breakpoint
        /// @param label Symbol label at which to add breakpoint
        /// @returns True - Breakpoint added
        //           False - Breakpoint already exists, or symbol 'label' not found
        ///////////////////////////////////////////////////////////////////////////////////////////
        bool AddBreakpoint(std::string label);

        ///////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Remove breakpoint
        /// @param address Address in program from which to remove the breakpoint
        /// @returns True - When breakpoint was erased, False when no breakpoint exist at address.
        ///////////////////////////////////////////////////////////////////////////////////////////
        bool RemoveBreakPoint(uint32_t address);

        ///////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Remove breakpoint
        /// @param label Symbol label at which to add breakpoint
        /// @returns True - Breakpoint removed
        //           False - No such breakpoint or symbol with 'label' exist
        ///////////////////////////////////////////////////////////////////////////////////////////
        bool RemoveBreakPoint(std::string label);

        ///////////////////////////////////////////////////////////////////////////////////////////
        /// @returns True - When there exists brekapoint at address
        ///////////////////////////////////////////////////////////////////////////////////////////
        bool IsBreakpointAt(uint32_t address);

        ///////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Prints all breakpoints
        ///////////////////////////////////////////////////////////////////////////////////////////
        void PrintBreakpoints();

        ///////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Prints single breakpoint
        ///////////////////////////////////////////////////////////////////////////////////////////
        void PrintBreakpoint(uint32_t breakpoint);

        ///////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Prints GPR registers
        ///////////////////////////////////////////////////////////////////////////////////////////
        void PrintGprRegisters();

        ///////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Prints program counter
        ///////////////////////////////////////////////////////////////////////////////////////////
        void PrintPc();

        ///////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Prints CPU Flags
        ///////////////////////////////////////////////////////////////////////////////////////////
        void PrintFlags();

        ///////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Prints Contents of Return Address register stack
        ///////////////////////////////////////////////////////////////////////////////////////////
        void PrintRar();

        ///////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Prints Symbol Table
        ///////////////////////////////////////////////////////////////////////////////////////////
        void PrintSymbols();

        ///////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Starts the CPU simulator
        /// @param batch_mode True  - Start in batch mode
        ///                   False - Start in interactive mode
        /// @param file Command file to be executed by the simulator.
        ///////////////////////////////////////////////////////////////////////////////////////////
        void Start(bool batch_mode, const char* cmd_file);

        ///////////////////////////////////////////////////////////////////////////////////////////
        /// @returns True if program has already finished
        ///////////////////////////////////////////////////////////////////////////////////////////
        bool CheckFinished();

        ///////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Run the program
        ///////////////////////////////////////////////////////////////////////////////////////////
        void CmdRun();

        // Reference to CPU model executing the code
        CpuModel *model_;

        // Reference to compiler which compiled this program
        Compiler *compiler_;

        // Objects handling CLI and interactive simulation
        cli::Cli *cli_;
        //cli::LoopScheduler *scheduler_;
        //cli::CliLocalTerminalSession *session_;

    private:
        // Array of breakpoints break-points
        std::vector<uint32_t> breakpoints_;

        // Indication model execution is in progress
        bool program_running_ = false;

        void BuildCliCommands(std::unique_ptr<cli::Menu> &menu);

};

#endif